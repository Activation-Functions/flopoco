#ifndef OPERATOR_HPP
#define OPERATOR_HPP
#include<vector>
#include<map>
#include <gmpxx.h>
//#include "cpphdl/signal.hh"
#include "Target.hpp"
#include "Signal.hpp"
#include "TestCase.hpp"
#include "TestIOMap.hpp"

using namespace std;

// variables set by the command-line interface in main.cpp

extern  int verbose;

const std::string tab = "   ";

/* XXX: Moved Signal out of here, because
 * 1) It is to general and not strictly related only to Operator-s.
 * 2) To avoid circular dependency between Operator, TestBench, TestCase etc.
 */

/**
 * This is a top-level class representing an Operator.
 * This class is inherited by all classes which will output a
 * VHDL entity.
 */
class Operator
{
public:
	Operator()  {
		number_of_inputs=0;
		number_of_outputs=0;
		has_registers=false;
		has_registers_with_async_reset=false;
		has_registers_with_sync_reset=false;
	}

	Operator(Target* target_)  {
		target=target_;
		number_of_inputs=0;
		number_of_outputs=0;
		has_registers=false;
		has_registers_with_async_reset=false;
		has_registers_with_sync_reset=false;
	}
	
	virtual ~Operator() {}



	/** The following functions should be used to declare input and output signals,
	 excluding clk and rst */

	void add_input(const std::string name, const int width=1);
	void add_output(const std::string name, const int width=1);
	
	// equivalent to the previous for FP signals 
	void add_FP_input(const std::string name, const int wE, const int wF);
	void add_FP_output(const std::string name, const int wE, const int wF);
	
	/** The following should be used to declare standard signals */
	void add_signal(const std::string name, const int width=1);
	void add_signal_bus(const std::string name, const int width=1);
	
	/** The following should be used to declare registered signals: it
			will declare name and name_d, and output_vhdl_registers will
			build the registers between them. */
	void add_registered_signal(const std::string name, const int width=1);
	void add_registered_signal_with_async_reset(const std::string name, const int width=1);
	void add_registered_signal_with_sync_reset(const std::string name, const int width=1);

	Signal* get_signal_by_name(string s);

	/** The following adds a signal, and also a shift register on it of depth delay.
			There will be depth levels of registers, named name_d, name_d_d and so on.
			The string returned is the name of the last signal.
		*/
	string add_delay_signal(const std::string name, const int width, const int delay);
	string add_delay_signal_bus(const std::string name, const int width, const int delay);
	/** An helper function that return the name of an intermediate signal generated by add_delay_signal*/
	string  get_delay_signal_name(const string name, const int delay);

	//string add_level_delay_signal(const std::string name, const int start_level ,const int width, const int delay); 
	//string get_level_delay_signal_name(const string name, const int delay); 


	void output_vhdl_registers(std::ostream& o);


	// Helper functions for VHDL output
	
	/** Outputs component declaration */
	virtual void output_vhdl_component(std::ostream& o, std::string name);

	void output_vhdl_component(std::ostream& o);  // calls the previous with name = unique_name
	

	// Output the licence
	void Licence(std::ostream& o, std::string authorsyears);
	
	// output the standard library paperwork
	static void StdLibs(std::ostream& o){
		o<<"library ieee;\nuse ieee.std_logic_1164.all;"<<endl 
		 <<"use ieee.std_logic_arith.all;"<<endl
		 <<"use ieee.std_logic_unsigned.all;"<<endl 
		 <<"library work;"<<endl<<endl;
	};
		
	// output the identity 
	void output_vhdl_entity(std::ostream& o);

	// output all the signal declarations 
	void output_vhdl_signal_declarations(std::ostream& o);


	//a new line macro method
	void new_line(std::ostream& o);
	//a new architecture macro method
	void new_architecture(std::ostream& o, std::string name);
	//a begin architecture macro method
	void begin_architecture(std::ostream& o);
	//an end architecture macro method
	void end_architecture(std::ostream& o);


	// the main function outputs the VHDL for the operator
	virtual void output_vhdl(std::ostream& o, std::string name) =0 ;
	void output_vhdl(std::ostream& o);   // calls the previous with name = unique_name



	// Functions related to pipelining (work in progress)
	
	bool is_sequential();  // true if the operator needs a clock signal. It will also get a rst but doesn't need to use it
	void set_sequential(); 
	void set_combinatorial();
	int pipeline_depth();
	void increment_pipeline_depth();
	void set_pipeline_depth(int d);


	//
	// Functions related to test case generation
	//

	/**
	 * Gets the signals which are interesting for TestCases.
	 * @see TestIOMap
	 */
	virtual TestIOMap getTestIOMap() {
		throw std::string("getTestIOMap: not implemented for ") + unique_name;
	}

	/**
	 * Gets the correct value associated to one or more inputs.
	 * @param a the array which contains both already filled inputs and
	 *          to be filled outputs in the order specified in getTestIOMap.
	 */
	virtual void fillTestCase(mpz_class a[]) {
		throw std::string("fillTestCorrectValues: not implemented for ") + unique_name;
	}
	
	/**Final report function, prints to the terminal.  By default
		 reports the pipeline depth, but feel free to overload if you have
		 anything useful to tell to the end user
	*/
	virtual void output_final_report();




	string unique_name;
	
	vector<Signal*> ioList; 
	vector<Signal*> signalList; 
//   vector<Signal*> registerList; 
//   vector<Signal*> register_with_resetList; 

protected:    

	Target* target;

private:
	int number_of_inputs;
	int number_of_outputs;
	bool _is_sequential;  // true if the operator needs a clock signal. It will also get a rst but doesn't need to use it
	int _pipeline_depth;
	map<string, Signal*> _signal_map; 

	bool has_registers;
	bool has_registers_with_async_reset;
	bool has_registers_with_sync_reset;

};


#endif
