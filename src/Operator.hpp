#ifndef OPERATOR_HPP
#define OPERATOR_HPP
#include<vector>
#include<map>
#include <gmpxx.h>
#include "Target.hpp"
#include "Signal.hpp"
#include "TestCase.hpp"
#include "TestIOMap.hpp"

using namespace std;

// variables set by the command-line interface in main.cpp

extern  int verbose;
const std::string tab = "   ";

/**
 * This is a top-level class representing an Operator.
 * This class is inherited by all classes which will output a
 * VHDL entity.
 */
class Operator
{
public:
	/* Constructors|Destructor */
	/* ======================= */ 
	Operator()  {
		number_of_inputs=0;
		number_of_outputs=0;
		has_registers=false;
		has_registers_with_async_reset=false;
		has_registers_with_sync_reset=false;
	}
	Operator(Target* target_)  {
		target=target_;
		number_of_inputs=0;
		number_of_outputs=0;
		has_registers=false;
		has_registers_with_async_reset=false;
		has_registers_with_sync_reset=false;
	}
		
	virtual ~Operator() {}

	/* Functions for declaring signals */
	/* =============================== */
	/** The following functions should be used to declare input and output signals, excluding clk and rst */
	void add_input(const std::string name, const int width=1);
	void add_output(const std::string name, const int width=1);
	
	/** equivalent to the previous, but for FP signals */
	void add_FP_input(const std::string name, const int wE, const int wF);
	void add_FP_output(const std::string name, const int wE, const int wF);
	
	/** The following should be used to declare standard signals */
	void add_signal(const std::string name, const int width=1);
	void add_signal_bus(const std::string name, const int width=1);
	
	/** The following should be used to declare registered signals: it
			will declare name and name_d, and output_vhdl_registers will
			build the registers between them. */
	void add_registered_signal(const std::string name, const int width=1);
	void add_registered_signal_with_async_reset(const std::string name, const int width=1);
	void add_registered_signal_with_sync_reset(const std::string name, const int width=1);

	/** The following adds a signal, and also a shift register on it of depth delay.
			There will be depth levels of registers, named name_d, name_d_d and so on.
			The string returned is the name of the last signal. */
	string add_delay_signal(const std::string name, const int width, const int delay);
	string add_delay_signal_no_reset(const std::string name, const int width, const int delay);
	string add_delay_signal_bus(const std::string name, const int width, const int delay);
	string add_delay_signal_bus_no_reset(const std::string name, const int width, const int delay);
	
	/** An helper function that return the name of an intermediate signal generated by add_delay_signal.
	 If the operator is not sequential, it returns name, so it can be used for both the sequential and pipelined VHDL output */
	string  get_delay_signal_name(const string name, const int delay);

	/* Accessor methods */ 
	/* ================ */
	/** Sets Operator name to default name*/
	void set_operator_name();
	/** Sets Operator name to givenName*/
	void set_operator_name(std::string operatorName);
	/** Sets Operator name to prefix_defaultName_postfix*/
	virtual void set_operator_name(std::string prefix, std::string postfix){};
	/** Sets the type of the operator */
	void set_operator_type();
	/** Sets the commented name of an operator */
	void setCommentedName(std::string name);
	
	/** return the operator name */
	string getOperatorName() const;
	/** return the number of input+output signals */
	int getIOListSize() const;
	/** returns a pointer to the list containing the IO signals */
	vector<Signal*> * getIOList();
	
	const Signal * getIOListSignal(int i);
	
	
	/** Returns a pointer to the signal having the name s */
	Signal* get_signal_by_name(string s);

	/* Helper functions for VHDL output */
	/* ================================ */
	/** Outputs component declaration */
	virtual void output_vhdl_component(std::ostream& o, std::string name);
	/** calls the previous with name = unique_name */
	void output_vhdl_component(std::ostream& o);  
	/** Function which outputs the processes which declare the registers ( assign name_d <= name ) */
	void output_vhdl_registers(std::ostream& o);
	/** Output the licence */
	void Licence(std::ostream& o, std::string authorsyears);
	/** output the standard library paperwork */
	static void StdLibs(std::ostream& o){
		o<<"library ieee;\nuse ieee.std_logic_1164.all;"<<endl 
		 <<"use ieee.std_logic_arith.all;"<<endl
		 <<"use ieee.std_logic_unsigned.all;"<<endl 
		 <<"library work;"<<endl<<endl;
	};
	/** output the identity */
	void output_vhdl_entity(std::ostream& o);
	/** output all the signal declarations */
	void output_vhdl_signal_declarations(std::ostream& o);

	/**
	 * A new line function
	 * @param[in,out] o - the stream to which the new line will be added
	 **/
	inline void new_line(std::ostream& o) {	o<<endl; }
	
	/**
	 * A new architecture function
	 * @param[in,out] o 	- the stream to which the new architecture line will be added
	 * @param[in]     name	- the name of the entity corresponding to this architecture
	 **/
	inline void new_architecture(std::ostream& o, std::string name){
		o << "architecture arch of " << name  << " is" << endl;
	}
	
	/**
	 * A begin architecture function 
	 * @param[in,out] o 	- the stream to which the begin line will be added
	 **/
	inline void begin_architecture(std::ostream& o){
		o << "begin" << endl;
	}

	/**
	 * A end architecture function 
	 * @param[in,out] o 	- the stream to which the begin line will be added
	 **/
	inline void end_architecture(std::ostream& o){
		o << "end architecture;" << endl << endl;
	}

	/** the main function outputs the VHDL for the operator */
	virtual void output_vhdl(std::ostream& o, std::string name) =0 ;
	void output_vhdl(std::ostream& o);   // calls the previous with name = unique_name

	/* Functions related to pipelining (work in progress) */
	/* ================================================== */
	/** true if the operator needs a clock signal. It will also get a rst but doesn't need to use it */	
	bool is_sequential();  
	/** Set the operator to sequential*/	
	void set_sequential(); 
	/** Set the operator to combinatorial*/	
	void set_combinatorial();
	/** Set the depth of the pipeline*/	
	void set_pipeline_depth(int d);
	/** Gets the pipeline depth of this operator */
	int pipeline_depth();
	/** Increments the pipeline depth of the current operator */
	void increment_pipeline_depth();
	
	/* Functions related to test case generation */
	/* ========================================= */
	/**
	 * Gets the signals which are interesting for TestCases.
	 * @see TestIOMap
	 */
	virtual TestIOMap getTestIOMap() {
		throw std::string("getTestIOMap: not implemented for ") + unique_name;
	}

	/**
	 * Gets the correct value associated to one or more inputs.
	 * @param a the array which contains both already filled inputs and
	 *          to be filled outputs in the order specified in getTestIOMap.
	 */
	virtual void fillTestCase(mpz_class a[]) {
		throw std::string("fillTestCorrectValues: not implemented for ") + unique_name;
	}
	
	
	/* MISC */
	/* ==== */
	/** Final report function, prints to the terminal.  By default
		 reports the pipeline depth, but feel free to overload if you have
		 anything useful to tell to the end user
	*/
	virtual void output_final_report();

protected:    
	/** The target on which the operator will be deployed */
	Target* target;
	/** By default, a name derived from the operator class and the parameters.
	 Also possibly overrriden by the command line interface or by other means */
	string unique_name;
	/** The list of I/O signals of the operator */
	vector<Signal*> ioList; 
	/** The list of internal signals of the operator */
	vector<Signal*> signalList; 



private:
	/** The number of inputs of the operator */
	int number_of_inputs;
	/** The number of outputs of the operator */
	int number_of_outputs;
	/** true if the operator needs a clock signal. It will also get a rst but doesn't need to use it */
	bool _is_sequential;  
	/** the pipeline depth of the operator. 0 for combinatorial circuits */
	int _pipeline_depth;
	/** a container of tuples of the form (string, *Signal) for easily recovering the signal based on it's name */
	map<string, Signal*> _signal_map; 
	/** true if the operator has registers without a reset */
	bool has_registers;
	/** true if the operator has registers having an asynch reset */
	bool has_registers_with_async_reset;
	/** true if the operator has registers having a synch reset */
	bool has_registers_with_sync_reset;
	/** Usually is the default name of the architecture.  */
	string commented_name;
};

#endif
