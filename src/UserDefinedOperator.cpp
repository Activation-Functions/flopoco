// general c++ library for manipulating streams
#include <iostream>
#include <sstream>

/* header of libraries to manipulate multiprecision numbers
  There will be used in the emulate function to manipulate arbitraly large
  entries */
#include "gmp.h"
#include "mpfr.h"
#include "BitHeap.hpp"
#include "Plotter.hpp"
// include the header of the Operator
#include "UserDefinedOperator.hpp"

using namespace std;


// personalized parameter
string UserDefinedOperator::operatorInfo = "UserDefinedInfo param0 param1 <options>";


static string x(int i) {
	ostringstream s;
	s << "X" << of(i);
	return s.str();
} 


UserDefinedOperator::UserDefinedOperator(Target* target, int w_, int s_, int g_) : Operator(target) {
/* constructor of the UserDefinedOperator
  Target is the targeted FPGA : Stratix, Virtex ... (see Target.hpp for more informations)
  param0 and param1 are some parameters declared by this Operator developpers, 
  any number can be declared, you will have to modify 
      -> this function,  
      -> the prototype of this function (available in UserDefinedOperator.hpp)
      -> the lines in main.cpp where the command line arguments are parsed in order to generate this UserDefinedOperator
*/
  /* In this constructor we are going to generate an operator that takes as input three bit vectors X,Y,Z of lenght param0, treats them as unsigned integers, sums them and then output the last param1 bit of the sum adding the first bit of the sum (most significant) in front of this output, all the vhdl code needed by this operator has to be generated in this function */

  int w=w_;  // size of x
  int shift=s_;  // x<1b-s
  int g=g_;  // guard bits, to be computed some day
  // definition of the name of the operator
  ostringstream name;
  name << "PolySin_" << w_ << "_"<< shift <<  "_" << g ;
  setName(name.str());
  // Copyright 
  setCopyrightString("ACME and Co 2010");

  /* SET UP THE IO SIGNALS
        Each IO signal is declared by addInput(name,n) or addOutput(name,n) 
    where name is a string that stands for the name of the variable and 
    n is an integer (int)   that stands for the length of the corresponding 
    input/output */


  // declaring inputs
  addInput ("X" , w);

  BitHeap* bh = new BitHeap(this, w+g);
  Plotter* plotter = new Plotter(bh);
  bh->setPlotter(plotter);

  double err = 0;

  // Tout est align√© sur X
  for(int i=0; i<w; i++) {
	  bh-> addBit(i+g, x(i));
  }

  manageCriticalPath(target->lutDelay());
  // div by 3
  for(int i=0; i<w-3*shift +g-1; i++) {
		  int weight = i;
		  if(weight>=0)
			  bh-> addBit(i, "resOfDivBy3");
		  else
			  err += 1.0/(double)(1 << (-weight));
  }

  manageCriticalPath(target->lutDelay());

  for(int i=0; i<w; i++) {
	  for(int j=0; j<i; j++) {
		  ostringstream s;
		  s << "X" << of(i) << " and " << "X" << of(j);
		  int weight = i+2*j - 3*w -3*shift + w+g;
		  if(weight>=0)
			  bh-> addBit(weight,  s.str());
		  else
			  err += 1.0/(double)(1 << (-weight));
	  }
  }
  manageCriticalPath(target->lutDelay());

  for(int i=0; i<w; i++) {
	  for(int j=0; j<i; j++) {
		  for(int k=0; k<j; k++) {
			  ostringstream s;
			  s << "X" << of(i) << " and " << "X" << of(j) << " and " << "X" << of(k);
			  int weight = i+j+k  - 3*w -3*shift + w+g;
		  if(weight>=0)
			  bh-> addBit(weight,  s.str());
		  else
			  err += 1.0/(double)(1 << (-weight));
		  }
			  
	  }
  }

  cout << "err=" << err << "   in ulps" << err / (double)(1<<g);


  bh -> generateCompressorVHDL();			

  vhdl << "R" << " <= " << bh-> getSumName() << range(w+g - 1,g) << ";" << endl;
};

	
void UserDefinedOperator::emulate(TestCase * tc) {
  /* This function will be used when the TestBench command is used in the command line
    we have to provide a complete and correct emulation of the operator, in order to compare correct output generated by this function with the test input generated by the vhdl code */
  /* first we are going to format the entries */
  mpz_class sx = tc->getInputValue("X");
  mpz_class sy = tc->getInputValue("Y");
  mpz_class sz = tc->getInputValue("Z");

  /* then we are going to manipulate our bit vectors in order to get the correct output*/
  mpz_class sr;
  mpz_class stmp;
  stmp = sx + sy + sz;
  sr = (stmp % mpzpow2(param1)); // we delete all the bits that do not fit in the range (param1 - 1 downto 0);
  sr += (stmp / mpzpow2 (param0+1)); // we add the first bit

  /* at the end, we indicate to the TestCase object what is the expected
    output corresponding to the inputs */
  tc->addExpectedOutput("R",sr);
}


void UserDefinedOperator::buildStandardTestCases(TestCaseList * tcl) {
	// please fill me with regression tests or corner case tests!
}
