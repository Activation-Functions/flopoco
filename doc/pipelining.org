New pipeline, internal documentation (work in progress)

* Big picture:
** Current choice
The scheduler is invoked after each vhdl statement.

** Abandoned alternative 
The following alternative was considerered (and even completely implemented):
1/ build the complete signal dependency graph, 
2/ schedule it optimally (i.e. better than ASAP in principle)
The problem is that in many cases, we want to take decisions in the architecture depending on the scheduling of the inputs.
Examples: pipelined adders, bit heap compressors, etc.
This is perceived more important than the possible benefit of optimality over ASAP.
However, it implies an input-to-output scheduling flow (typically ASAP).

** Scheduling  
Flow: start with the inputs of the circuit. The inputs are all synchronized
		at the same cycle, and their critical path might vary. Each input
		computes its timing and then starts the timing of its successors.
		When the timing is called on an internal node (i.e. not an input),
		the node first checks if the node has already been scheduled. If yes,
		then stop the timing procedures, as there is nothing else to do (this
		might also be a backward loop).
		Then, check if all of the predecessors have been scheduled.
		If yes, then the node schedules itself, according to the timing of
		its predecessors and to its own constraints, and then launches the timing
		of its own sucessors.
		If not, then the timing procedures are stopped. This can be done
		because it means that the node depends on another node that hasn't
		yet been scheduled. When the predecessor will finally be scheduled,
		the launch of the timing for the respective node will also be triggered.

Backward loops: When dealing with a loop, the timing procedures will come
		to a halt inside the loop, as they will detect that the node which has
		data coming from the backward edge has already been scheduled, so there
		is nothing else left to do.

Sub-components: start by launching the scheduling procedures on the signals
		of the operator.
		We first schedule the signal, and then detect whether the signal and
		its predecessors belong to the same operator (meaning the signal belongs to
		a sub-component of the parent operator of the respective signal's predecessor).
		If this is not an input signal, we start scheduling the signal's sucessors.
		If this is an input signal, we then check if all of the other inputs of the
		respective sub-component have also been scheduled. If not, we can just
		stop the current call. If yes, then we synchronize all of the inputs to
		the same cycle, and then launch the scheduling procedure for the
		sub-component.
		When encountering an output port, the scheduling procedures should
		treat it as a regular signal: set its timing and launch the scheduling
		of its successors.

** technicallities
*** First level parsing
In the VHDL stream,
- Left-hand-side identifiers are surrounded with ??
- Right-hand-side identifiers are surrounded with $$
- These include non-signal IDs such as conv_std_logic_vector etc.
  The latter will be filtered out (i.e. transmitted to the output VHDL with no change) thanks to the signal dictionary information.
Examples (taken from FPAdd)

   ??R?? <= $$X$$ + $$Y$$ + $$Cin$$;

   fracAdder: ??IntAdder_27_F400_uid11??
      port map ( ??clk??  => $$clk$$,
                 ??rst??  => $$rst$$,
                 ??Cin?? => $$cInAddFar$$,
                 ??X?? => $$fracXfar$$,
                 ??Y?? => $$fracYfarXorOp$$,
                 ??R?? => $$fracAddResult$$);

   ??shiftVal?? <= $$expDiff$$(4 downto 0) when $$shiftedOut$$='0' else $$CONV_STD_LOGIC_VECTOR$$(26,5);

   with $$sXsYExnXY$$ select 
   ??excRt?? <= "00" when "000000"|"010000"|"100000"|"110000",
      "01" when "000101"|"010101"|"100101"|"110101"|"000100"|"010100"|"100100"|"110100"|"000001"|"010001"|"100001"|"110001",
      "10" when "111010"|"001010"|"001000"|"011000"|"101000"|"111000"|"000010"|"010010"|"100010"|"110010"|"001001"|"011001"|"101001"|"111001"|"000110"|"010110"|"100110"|"110110", 
      "11" when others;
