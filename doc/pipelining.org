New pipeline, internal documentation (work in progress)

* Big picture:
** The VHDL Lexer
The VHDL Lexer (implemented in src/VHDLLexerRule.l) 
- builds the signal graph in dependenceTable
- invokes the scheduler at each ";"


* Abandoned alternative 
The following alternative was considerered (and even completely implemented):
1/ build the complete signal dependency graph, 
2/ schedule it optimally (i.e. better than ASAP in principle)
The problem is that in many cases, we want to take decisions in the architecture depending on the scheduling of the inputs.
Examples: pipelined adders, bit heap compressors, etc.
This is perceived more important than the possible benefit of optimality over ASAP.
However, it implies an input-to-output scheduling flow (typically ASAP).


* Copypasted obsolete stuff to remove once it has been pushed up.
** Scheduling  


*** Relevant methods: 
void Operator::startScheduling() will be obsoleted
void Operator::scheduleSignal(Signal *targetSignal)
void Operator::parse2()

*** Flow
start with the inputs of the circuit. 
The inputs are assumed to be all synchronized at the same cycle, and their critical path might vary.

When scheduleSignal() is called on an internal node (i.e. not an input), it first checks if the node has already been scheduled. 
If yes,	it exits:  there is nothing else to do (this might also be a backward loop).
Otherwise, check if all of the predecessors have been scheduled.
If yes, then the node schedules itself, according to the timing of its predecessors and to its own constraints.
Otherwise it simply exits: this signal will have to be scheduled in a recursive call (at the end of vhdl construction?)

scheduleSignalRecursive(s) starts by launching scheduleSignal(s), and then for each successor ss of s launches scheduleSignalRecursive()

*** Backward loops:
 When dealing with a loop, the timing procedures will come
		to a halt inside the loop, as they will detect that the node which has
		data coming from the backward edge has already been scheduled, so there
		is nothing else left to do.

*** Sub-components:
 start by launching the scheduling procedures on the signals
		of the operator.
		We first schedule the signal, and then detect whether the signal and
		its predecessors belong to the same operator (meaning the signal belongs to
		a sub-component of the parent operator of the respective signal's predecessor).
		If this is not an input signal, we start scheduling the signal's sucessors.
		If this is an input signal, we then check if all of the other inputs of the
		respective sub-component have also been scheduled. If not, we can just
		stop the current call. If yes, then we synchronize all of the inputs to
		the same cycle, and then launch the scheduling procedure for the
		sub-component.
		When encountering an output port, the scheduling procedures should
		treat it as a regular signal: set its timing and launch the scheduling
		of its successors.

** technicallities
*** First level parsing
In the VHDL stream,
- Left-hand-side identifiers are surrounded with ??
- Right-hand-side identifiers are surrounded with $$
- These include non-signal IDs such as conv_std_logic_vector etc.
  The latter will be filtered out (i.e. transmitted to the output VHDL with no change) thanks to the signal dictionary information.
Examples (taken from FPAdd)

   ??R?? <= $$X$$ + $$Y$$ + $$Cin$$;

   fracAdder: ??IntAdder_27_F400_uid11??
      port map ( ??clk??  => $$clk$$,
                 ??rst??  => $$rst$$,
                 ??Cin?? => $$cInAddFar$$,
                 ??X?? => $$fracXfar$$,
                 ??Y?? => $$fracYfarXorOp$$,
                 ??R?? => $$fracAddResult$$);

   ??shiftVal?? <= $$expDiff$$(4 downto 0) when $$shiftedOut$$='0' else $$CONV_STD_LOGIC_VECTOR$$(26,5);

   with $$sXsYExnXY$$ select 
   ??excRt?? <= "00" when "000000"|"010000"|"100000"|"110000",
      "01" when "000101"|"010101"|"100101"|"110101"|"000100"|"010100"|"100100"|"110100"|"000001"|"010001"|"100001"|"110001",
      "10" when "111010"|"001010"|"001000"|"011000"|"101000"|"111000"|"000010"|"010010"|"100010"|"110010"|"001001"|"011001"|"101001"|"111001"|"000110"|"010110"|"100110"|"110110", 
      "11" when others;
