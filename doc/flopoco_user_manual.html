<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.0//EN"
      "http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>FloPoCo user manual</title>
  <meta name="generator" content="Amaya 9.54, see http://www.w3.org/Amaya/" />
</head>

<body>
<h1>FloPoCo user manual</h1>

 <img src="FloPoCoLogoSmall.png">

<h2>Installation</h2>

<p>FloPoCo depends on the MPFR library, available from <a
href="http://www.mpfr.org">http://www.mpfr.org</a> and probably available in
your favourite Linux/Unix distribution. To compile it you need CMake (<a
href="http://www.cmake.org/">http://www.cmake.org/</a>) which also comes
prepackaged for mainstream Linux/Unix distributions.</p>

<p>Optionally, you may want to link FloPoCo
against <a href="http://sollya.gforge.inria.fr/">Sollya</a>. This
enables more operators (HOTBM, CRFPConstMult). For this purpose, you
must download,
compile and install <a href="http://sollya.gforge.inria.fr/">Sollya</a>.
FloPoCo is demonstrated to work with version 1.1 of Sollya and should work with future releases.
</p>

<p>Compilation is a two-step process:</p>

<p><code>cmake .</code></p>

<p><code>make</code></p>

<p>The adventurous may get FloPoCo from its <a
href="https://gforge.inria.fr/scm/?group_id=1030">subversion
repository</a>.</p>


<h2>Command-line interface</h2>

<p>FloPoCo is a command-line tool. The general syntax is</p>

<p><code>flopoco &lt;options&gt; &lt;operator specification
list&gt;</code></p>

<p>FloPoCo will generate a single VHDL file (named by default
<code>flopoco.vhdl</code>) containing synthesisable descriptions of all the
operators listed in <code>&lt;operator specification list&gt;</code>, plus
possibly sub-operators instanciated by them. To use these operators in your
design, just add this generated file to your project.</p>

<p>FloPoCo will also issue a report with useful information about the generated operators, such as the pipeline depth or expected working frequency.</p>

<h3>Examples</h3>

<p><code>./flopoco IntConstMult 16 12345</code></p>

<p>produces a file <code>flopoco.vhdl</code> containing a single operator for
the integer multiplication of an input 16-bit number by the constant 12345.
The VHDL entity is named after the operator specification, here
<code>IntConstMult_16_12345</code>.</p>

<p><code>./flopoco IntConstMult 16 12345 IntConstMult 16 54321</code></p>

<p>produces a file <code>flopoco.vhdl</code> containing two VHDL entities and
their architectures, for the two given constant multipliers. </p>

<p><code>./flopoco FPConstMult 8 23 8 23 0 -50 1768559438007110</code></p>

<p>produces a file flopoco.vhdl containing two VHDL entities, one for the
specified constant floating-point multiplier by 1768559438007110x2<sup>-50</sup>, and
the other one for a needed sub-component (an integer multiplier for the
significand multiplication).</p>

<h3>Options</h3>

<p>Several transversal options are available and will typically change the
operators occuring after them in the list. For
instance <code>-frequency=300</code> sets the target
frequency. The <code>-name=UserProvidedName</code> option replaces the
(ugly and parameter-dependent) name generated by FloPoCo for the next
operator with a user-provided one. This allows in particular to change
parameters while keeping the same entity name, so that these changes
are transparent to the rest of the project. Options related to pipelining are reviewed below.</p>

<p>The <code>-target</code> option selects the target FPGA family. We
try to optimize for the highest speed grade available for this
family (see below for pipelining options).</p>
<h3>Built-in help</h3>

<p>To obtain a concise list of the available operators and options, simply
type</p>

<p><code>./flopoco </code></p>

<p>In addition this help may be more in sync with the code than this file,
especially if you are using a svn snapshot.</p>

<h3>Helper programs</h3>

<p>The FloPoCo distributions also includes useful programs for converting the
binary string of a floating-point number to human-readable form
(<code>bin2fp</code>) and back (<code>fp2bin</code>). The
<code>longacc2fp</code> utility converts the fixed-point output of the
LongAcc operator (see below) to human-readable form.</p>

<p></p>

<h2>Floating-point format</h2>

<p>The floating-point format used in FloPoCo is identical to the one used in  <a
href="http://www.ens-lyon.fr/LIP/Arenaire/Ware/FPLibrary/">FPLibrary</a>. It is  inspired from the IEEE-754 standard, from which it differs only for exceptional cases (zeroes, infinities and Not a Number or NaN). Conversion operators from and to IEEE-754 formats (simple and double precision) are available, see below.</p>

<p>
An FP  number is a bit vector consisting of 4 fields. From left to right: 
<dl>
  <dt>A 2-bit exception field</dt>
    <dd>00 for zero, 01 for normal numbers, 10 for infinities, and 11 for NaN</dd>
  <dt>A sign bit</dt>
    <dd>0 for positive, 1 for negative</dd>
  <dt>An exponent field on wE bits</dt>
    <dd>It is biased as in IEEE-754. The smallest possible FP numbers have exponent field 00...00, the FP  number 1.0 has the exponent field 011...11 and the largest possible FP numbers have exponent 11...11 </dd>
  <dt>A fraction field on wF bits</dt>
    <dd>The actual significand has an implicit leading 1, so the fraction field ff...ff  represents the significand 1.ff...ff</dd>
</dl>
 </p>

<p>The format is therefore parameterized by to positive integers wE
and wF which define the sizes of the exponent and fraction fields
respectively.</p>

<p>The utilities <code>fp2bin</code> and <code>bin2fp</code> will allow
you to get familiar with the format and set up test benches. </p>

<h2>LNS format</h2>

<p>Numbers in the Logarithm Number System used in FloPoCo have an encoding
similar to the floating-point format, which is also the same as the one used in
<a
href="http://www.ens-lyon.fr/LIP/Arenaire/Ware/FPLibrary/">FPLibrary</a>.</p>

<p>Its fields are:
<dl>
  <dt>A 2-bit exception field</dt>
    <dd>Same encoding as floating-point: 00 for zero, 01 for the general case, 10 for infinities, and 11 for NaN</dd>
  <dt>A sign bit</dt>
    <dd>0 for positive, 1 for negative</dd>
  <dt>The integral part of the exponent on wE bits</dt>
  <dt>The fractional part of the exponent on wF bits</dt>
    <dd>The fixed-point exponent is encoded in two's-complement.</dd>
</dl>
</p>


<h2>Pipelining</h2>

<p>An operator may be combinatorial, or pipelined. A combinatorial operator has pipeline depth 0. An operator of pipeline depth 1 is obtained by inserting one and only one register on any path from an input to an output. Hopefully, this divides  the critical path delay by almost 2.  An operator of pipeline depth 2 is obtained by inserting two register levels, etc.</p>

<p>It should be noted that, according to this definition, pipelined
operators usually do not directly buffer neither their inputs nor
their outputs. For instance, connecting the input of a 400MHz operator
to the output of another 400MHz operator may well lead to a circuit
working at 200MHz only. It is the responsibility of the user or
calling program to insert one more level of registers between two
FloPoCo operators. This convention may be felt as a burden to the
user, but it is the most sensible choice. It makes it possible to
assemble sub-component without inserting registers in many situations,
thus reducing the latency of complex components. Besides, different
application contexts may have different policies (registers on output,
or registers on input). <p>

<p>Two command-line options control the pipelining of the FloPoCo
operators that follow them.

<dl>
  <dt><code>-pipeline=[yes|no]</code>  (default yes)</dt>
  <dt><code>-frequency=[frequency in MHz]</code>  (default 300)</dt>
    <dd>Sets the target frequency. If the <code>-pipeline</code>
    option is set, then FloPoCo will try to pipeline the operator to
    the given frequency. It will report a warning if it fails -- or if
    frequency-directed pipelining is not yet implemented for this
    operator.
	 </dd>
    <dd>
		Requires the operators to be pipelined. If <code>no</code>, the operator will be combinatorial. If <code>yes</code>,  registers
		may be inserted if needed to reach the target frequency. 
	 </dd>
</dl>
</p>


<p>The philosophy of FloPoCo's approach to pipelining is the following:
  <ul>
	 <li>FloPoCo's approach is to provide a fair estimate of the pipeline
		depth required to obtain a given frequency, and a sensible placement
		of registers.</li>
	 <li>FloPoCo's pipelining effort is always tentative: You may not
		get the frequency you asked (sometimes you will even get a
		higher one). However, in such cases, increasing or decreasing
		the target frequency should also increase or decrease the
		obtained frequency. Note that you may do so on a per-operator
		basis, as in: <code>flopoco -frequency=200 FPAdder 11 52
		-frequency=300 FPMultiplier 8 23</code></li>

	 <li> If the obtained frequency is higher than needed, reducing
	 the <code>-frequency</code> option may save resources.</li>

	 <li> The pipeline built by FloPoCo may depend on the target. When
	 tuning it, we use the best possible speed grade for a given target
	 family, for insance -12 for Virtex-4. If you want to target a FPGA
	 with a lower speed grade, you may need to
	 update <code>-frequency</code> accordingly.</li>

	 <li> Better results will always be obtained by using retiming
		tools, which can work on a circuit netlist after technology
		mapping. The pipeline built by FloPoCo should help these
		retiming tools converge faster to a global optimal.</li>
  </ul>
</p>
<p>Note that not all operators support pipelining (utimately they all will). They are mentionned in the command-line help.
</p>

<h2>Available operators</h2>

<p>Here is the list of operators that can be generated by
FloPoCo. This list may not be fully up-to date... the code is the
reference.</p>

<h3>Useful building blocks for FP operators</h3>

<dl>
  <dt><code>LeftShifter wIn MaxShift</code> </dt>
    <dd>Left barrel shifter. It has two inputs, the data to shift and a shift
      value. The width of the latter is deduced from MaxShift, which is the
      maximum shift distance. This operator will be pipelined to match target
      frequency.</dd>
  <dt><code>RightShifter wIn MaxShift</code> </dt>
    <dd>Same, but to the right.</dd>
  <dt><code>LZOC wIn wOut</code></dt>
    <dd>Leading Zero/One Counter.</dd>
  <dt><code>LZOCShifterSticky wIn wOut computeSticky countType</code></dt>
    <dd>Leading Zero/One Counter merged with a shifter. If
    computeSticky=0 the bits shifted out are discarded, if 1 they are
    ORed into a sticky bit. If countType=0, a leading zero counter is
    built, if 1 a leading one counter is built, if -1 the value to
    count is input from an extra input port.</dd>
</dl>

<h3>Pipelined integer standard operators</h3>
<dl>
  <dt><code>IntAdder wIn</code></dt>
    <dd>Integer adder. In modern VHDL, integer addition is expressed by a +
      and one usually needn't define an entity for it. However, this operator
      will be pipelined if the addition is too large to be performed at the
      target frequency. </dd>
  <dt><code>IntMultiplier wInX wInY</code></dt>
    <dd>Same for multiplication, although the frequency attainable will be
      limited by the DSP blocks available. wInX and wInY are the input widths
      of both operands. This is an unsigned operation.</dd>
    <dd></dd>
  <dt><code>IntSquarer wInX wInY</code></dt>
    <dd>Same for squaring. For large multiplications on some FPGAs, it
    saves DSP blocks (your mileage may vary).</dd>
    <dd></dd>
</dl>

<h3>Classical floating-point operators</h3> 

These operators are correctly rounded to the nearest, in a way
compatible with IEEE-754, with the exception that subnormal numbers
are flushed to zero.

<dl>
  <dt><code>FPMultiplier wE wF</code></dt>
    <dd>A floating-point multiplier. The actual FloPoCo
      component supports different input and output sizes, but this is
      not available from the command line.</dd>
  <dt><code>FPAdder wE wF</code></dt>
    <dd>A floating-point adder.</dd>
  <dt><code>FPDiv wE wF</code></dt>
    <dd>A floating-point divider.</dd>
  <dt><code>FPSqrt wE wF useDSP correctRounding</code></dt>
    <dd>A floating-point square root. useDSP (0/1) is a boolean selecting between the classical digit-recurrence algorithm and a polynomial-based algorithm. The latter is currently only available for single precision (8,23). correctRounding (0/1) is a boolean selecting the rounding mode for the polynomial approach. If set to 0, the operator will be faithful (last-bit accurate, but not necessarily correctly rounded). This boolean is ignored if useDSP=0: the digit-recurrence algorithm always returns correctly rounded results.</dd>
  <dt><code>FPSquarer wE wF</code></dt>
    <dd>A floating-point squarer, using IntSquarer for the mantissa.</dd>
</dl>

<h3>Long fixed-point accumulator, and derivatives</h3>
These operators are described in all the gory details
in <a href="http://prunel.ccsd.cnrs.fr/ensl-00268348/">this
article</a>.
<dl>
  <dt><code>LongAcc wE_in wF_in MaxMSB_in LSB_acc MSB_acc</code></dt>
    <dd>Long fixed-point accumulator. By tuning
    the <code>MaxMSB_in</code>, <code>LSB_acc</code>
    and <code>MSB_acc</code> parameters to a given application, it
    allows one to bring rounding error to a provably arbitrarily small
    level (and in some case to avoid any rounding), for a very small hardware cost compared to using a
    floating-point adder for accumulation.
	 </dd>
  <dt><code>DotProduct wE_in wF_X wF_Y MaxMSB_in LSB_acc MSB_acc</code></dt>
    <dd>Dot product operator. It feeds a long accumulator with the
      unrounded result of a floating-point multiplier, thus removing
      rounding errors from the multiplication as well.
	 </dd>
  <dt><code>LongAcc2FP MaxMSB_in LSB_acc MSB_acc wE_out wF_out</code></dt>
    <dd>  Post-normalisation unit for LongAcc. It converts the output of a
      LongAcc or DotProduct (with the same parameters) into a floating-point
      number.
	 </dd>
</dl>



<h3>Constant multipliers</h3>

<p>This family of operators is described in all the gory details in <a
href="http://prunel.ccsd.cnrs.fr/ensl-00269219/">this article</a>.</p>
<dl>
  <dt><code>IntConstMult w c</code></dt>
    <dd>integer constant multiplier: w is input size, c is the constant.</dd>
  <dt><code>FPConstMult wE_in wF_in wE_out wF_out cst_sgn cst_exp
  cst_int_sig</code></dt>
    <dd>floating-point constant multiplier. The constant is provided as sign,
      integral significand and integral exponent.</dd>
</dl>


<h3>Floating-point elementary functions</h3>

<dl>
	<dt><code>FPExp wE wF</code></dt>
	<dd>An exponential operator, where both inputs and outputs  have <code>wE</code> bits exponent and
	<code>wF</code> bits significand. This operator implements the exponential function as described in
	<a href="http://perso.ens-lyon.fr/florent.de.dinechin/recherche/publis/2007-Arith.pdf">this article</a>.
	</dd>

	<dt><code>FPLog wE wF</code></dt>
	<dd>A natural logarithm operator, where both inputs and outputs  have <code>wE</code> bits exponent and
	<code>wF</code> bits significand. This operator implements the natural logarithm function as described in
<a href="http://perso.ens-lyon.fr/florent.de.dinechin/recherche/publis/2007-Arith.pdf">this article</a>.
	</dd>
</dl>	


<h3>Conversion operators</h3>
<dl>
	<dt><code> Fix2FP LSB MSB wE wF</code></dt>
	<dd>Convert a 2's complement fixed-point number in the bit range MSB...LSB (both
	included) into floating-point. Example: 
	  <code>Fix2FP 0 31 8 23</code> converts an input integer into a single-precision number.
	</dd>
	<dt><code>InputIEEE wEI wFI wEO wFO</code></dt>
	<dd>Conversion from IEEE-754 formats.  Use <code>InputIEEE 8 23 wEO
	wFO</code> to convert from single-precision (or binary32) format,
	or <code>InputIEEE 11 52 wEO wFO</code> to convert from
	double-precision (or binary64) format. You may convert to a larger internal format or to a narrower one. Conversions are always correctly rounded. 
	</dd>
	<dt><code>OurputIEEE wEI wFI wEO wFO</code></dt>
	<dd>Conversion to IEEE-754 formats. Not implemented yet. Do not hesitate to ask for it.
	</dd>
	<dt><code>FP2FP wEI wFI wEO wFO</code></dt>
	<dd>Conversion from a FloPoCo format to another one.  Not implemented yet. Do not hesitate to ask for it.
	</dd>
</dl>	


<h3>Miscelanous floating-point operators</h3>


<dl>
	<dt><code>Collision wE wF</code></dt>
	<dd>A collision operator. This is mostly a case study for a compound operator. It is described in 
	<a href="http://prunel.ccsd.cnrs.fr/ensl-00379154/">this article</a>.
	</dd>
</dl>	



<h3>HOTBM</h3>

<p>This operator implements an arbitrary function using
High-Order Table-Based Method, best described in 
<a href="http://perso.ens-lyon.fr/florent.de.dinechin/recherche/publis/2005-ASAP.pdf">this article</a>.</p>

<dl>
	<dt><code>HOTBM func wI wO degree</code></dt>
	<dt><code>HOTBMFX func wE_in wF_in wE_out wF_out degree</code></dt>
	<dt><code>HOTBMRange func wI wO degree xmin xmax scale</code></dt>
	<dd>HOTBM implementation of a function. <code>func</code> is a
	  sollya-like expression of the function, <code>wI</code> is the
	  input width, <code>wO</code> is the output width and <code>degree</code>
	  is the degree of the Remez polynomial.
	  <code>wE_in</code>, <code>wF_in</code>, <code>wE_out</code>, <code>wF_out</code>
	  are the width of the integral and fractional parts of the input and the output,
	  respectively.
	  [<code>xmin</code>, <code>xmax</code>] is the input domain of the
	  function, and <code>scale</code> is a scaling factor to be applied to
	  the output.
	</dd>
</dl>

<p>For HOTBM the input operand is interpreted as a positive fixed-point number,
with the point before the leftmost bit. The function to be implemented
is assumed to be well defined in [0;1[. The output is a fixed-point
number, where the first bit is the sign and the point is placed right
after it. Note that the output is in fact <code>wO+1</code> bits
wide.</p>

<p>Due to the fact that the expression of the function might contain
characters which are treated specially by the shell, you should
enclose it within quotes.</p>

<p>Example:<br/>
<code>flopoco HOTBM "sin(x*Pi/2)" 16 16 3</code>
</p>

<p>The HOTBMFX version allows to select arbitrary fixed-point representations for the
input and output. Negative values are allowed.</p>

<p>Example:<br/>
<code>flopoco HOTBMFX "log2(1+2^(-x))" 2 8 -1 8 1</code>
</p>

<p>HOTBMRange uses HOTBM after mapping [<code>xmin</code>,<code>xmax</code>[ to [0,1[, then multiplies the output by the scaling factor <code>scale</code>.</p>

<p>Note that this launches an exploration process that typically takes a few minutes for 16 bits, and may take hours for 24 bits.</p>

<p>HOTBM uses a polynomial approximation. It works well for functions
which are regular enough (in mathematical terms, they should be
defined and n-times continuously differentiable on the domain).<p>

<h3>LNS</h3>

<p>These operators compute in the Logarithmic Number System. They are mostly useful
for low-precisions systems performing few additions and many multiplications, divisions
or square roots.</p>

<p>
<dl>
	<dt><code>LNSAddSub wE wF</code></dt>
	<dd>
		LNS addition operator. Both operands and the output have
		<code>wE</code> integral bits and <code>wF</code> fractional
		bits in their exponents.
	</dd>
	<dt><code>LNSMul wE wF</code></dt>
	<dd>
		LNS multiplication operator. Both operands and the output have
		<code>wE</code> integral bits and <code>wF</code> fractional
		bits in their exponents.
	</dd>
	<dt><code>LNSDiv wE wF</code></dt>
	<dd>
		LNS division operator. Both operands and the output have
		<code>wE</code> integral bits and <code>wF</code> fractional
		bits in their exponents.
	</dd>
	<dt><code>LNSSqrt wE wF</code></dt>
	<dd>
		LNS square root operator. Both input and output have
		<code>wE</code> integral bits and <code>wF</code> fractional
		bits in their exponents.
	</dd>
</dl>
</p>

<h3>Test Benches</h3>

The <code>TestBench</code> operator will generate a test bench for
the operator which precedes it in the command line (also called
unit under test, UUT).

Test cases are highly UUT specific. They include both standard tests
and random tests. The single parameter of the <code>TestBench</code>
specifies the number of random tests to generate. Random tests
use a pseudo-random number generator
initialised with the same seed, so that the test bench will be
deterministic.


<p>Example:<br/>
<code>flopoco HOTBM "sin(x*Pi/2)" 16 16 3 TestBench 1000</code>
</p>


<!--
<code>BigTestBench</code> is similar to <code>TestBench</code> but is
optimized for large tests (up to 1 million). It generates a very short VHDL code, which
reads test vectors from a predetermined file (the filename is
<code>operator_unique_name.test</code>). However, <code>BigTestBench</code> has the
disadvantage that the test file looks like a big blob and it is very hard to debug
problems, especially for pipelined designs. Therefore, it is recommended to use this
operator only when <code>TestBench</code> is successful, and one wants to be really
sure that the UUT is working perfectly.

<p>Example:<br/>
<code>flopoco FPExp 8 16 BigTestBench 200000</code>
</p>
-->

<h3>Miscellanous</h3>
<dl>
  <dt><code>Wrapper</code></dt>
    <dd>Produce a wrapper for the preceding operator: this operator simply adds registers before and after the preceding operator.
      It is useful in some cases to get synthesis results without having the operator optimised
      out, or to get critical path information  including the delay of the first and last stages connected to registers, not to I/O.
	 </dd>
</dl>
</body>
</html>
