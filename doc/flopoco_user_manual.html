<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.0//EN"
      "http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>FloPoCo user manual</title>
  <meta name="generator" content="Amaya 9.54, see http://www.w3.org/Amaya/" />
</head>

<body>
<h1>FloPoCo user manual</h1>

 <img src="FloPoCoLogoSmall.png">

<h2>Installation</h2>

<p>To compile FloPoCo you need CMake (<a
href="http://www.cmake.org/">http://www.cmake.org/</a>) which is included in  mainstream Linux/Unix distributions, and is available for other operating systems, including Windows.</p>

<p>FloPoCo also depends on the MPFR library, available from <a
href="http://www.mpfr.org">http://www.mpfr.org</a> and probably available in
your favourite Linux/Unix distribution. </p>

<p>Optionally, you may want to link FloPoCo
against <a href="http://sollya.gforge.inria.fr/">Sollya</a>. This
enables more operators (HOTBM, CRFPConstMult). For this purpose, you
must download,
compile and install <a href="http://sollya.gforge.inria.fr/">Sollya</a>.
FloPoCo is demonstrated to work with version 1.1 of Sollya and should work with future releases.
</p>

<p>Compilation is a two-step process:</p>

<p><code>cmake .</code></p>

<p><code>make</code></p>

<p>The adventurous may get FloPoCo from its <a
href="https://gforge.inria.fr/scm/?group_id=1030">subversion
repository</a>.</p>


<h2>Command-line interface</h2>

<p>FloPoCo is a command-line tool. The general syntax is</p>

<p><code>flopoco &lt;options&gt; &lt;operator specification
list&gt;</code></p>

<p>FloPoCo will generate a single VHDL file (named by default
<code>flopoco.vhdl</code>) containing synthesisable descriptions of all the
operators listed in <code>&lt;operator specification list&gt;</code>, plus
possibly sub-operators instanciated by them. To use these operators in your
design, just add this generated file to your project.</p>

<p>FloPoCo will also issue a report with useful information about the generated operators, such as the pipeline depth or expected working frequency.</p>

<h3>Examples</h3>

<p><code>./flopoco IntConstMult 16 12345</code></p>

<p>produces a file <code>flopoco.vhdl</code> containing a single operator for
the integer multiplication of an input 16-bit number by the constant 12345.
The VHDL entity is named after the operator specification, here
<code>IntConstMult_16_12345</code>.</p>

<p><code>./flopoco IntConstMult 16 12345 IntConstMult 16 54321</code></p>

<p>produces a file <code>flopoco.vhdl</code> containing two VHDL entities and
their architectures, for the two given constant multipliers. </p>

<p><code>./flopoco FPConstMult 8 23 8 23 0 -50 1768559438007110</code></p>

<p>produces a file flopoco.vhdl containing two VHDL entities, one for the
specified constant floating-point multiplier by 1768559438007110x2<sup>-50</sup>, and
the other one for a needed sub-component (an integer multiplier for the
significand multiplication).</p>

<h3>Options</h3>

<p>Several transversal options are available and will typically change the
operators occuring after them in the list. For
instance <code>-frequency=300</code> sets the target
frequency. The <code>-name=UserProvidedName</code> option replaces the
(ugly and parameter-dependent) name generated by FloPoCo for the next
operator with a user-provided one. This allows in particular to change
parameters while keeping the same entity name, so that these changes
are transparent to the rest of the project. Options related to pipelining are reviewed below.</p>

<p>The <code>-target</code> option selects the target FPGA family. We
try to optimize for the highest speed grade available for this
family (see below for pipelining options).</p>
<h3>Built-in help</h3>

<p>To obtain a concise list of the available operators and options, simply
type</p>

<p><code>./flopoco </code></p>

<p>In addition this help may be more in sync with the code than this file,
especially if you are using a svn snapshot.</p>

<h3>Helper programs</h3>

<p>The FloPoCo distributions also includes useful programs for converting the
binary string of a floating-point number to human-readable form
(<code>bin2fp</code>) and back (<code>fp2bin</code>). The
<code>longacc2fp</code> utility converts the fixed-point output of the
LongAcc operator (see below) to human-readable form.</p>

<p></p>

<h2>Floating-point format</h2>

<p>The floating-point format used in FloPoCo is identical to the one used in  <a
href="http://www.ens-lyon.fr/LIP/Arenaire/Ware/FPLibrary/">FPLibrary</a>. It is  inspired from the IEEE-754 standard.</p>

<p>
An FP  number is a bit vector consisting of 4 fields. From left to right: 
<dl>
  <dt>A 2-bit exception field</dt>
    <dd>00 for zero, 01 for normal numbers, 10 for infinities, and 11 for NaN</dd>
  <dt>A sign bit</dt>
    <dd>0 for positive, 1 for negative</dd>
  <dt>An exponent field on wE bits</dt>
    <dd>It is biased as in IEEE-754. The smallest possible FP numbers have exponent field 00...00, the FP  number 1.0 has the exponent field 011...11 and the largest possible FP numbers have exponent 11...11 </dd>
  <dt>A fraction field on wF bits</dt>
    <dd>The actual significand has an implicit leading 1, so the fraction field ff...ff  represents the significand 1.ff...ff</dd>
</dl>
 </p>

<p>The format is therefore parameterized by to positive integers wE
and wF which define the sizes of the exponent and fraction fields
respectively.</p>

<p>The utilities <code>fp2bin</code> and <code>bin2fp</code> will allow
you to get familiar with the format and set up test benches. </p>

<h3>Difference between FloPoCo format and IEEE-754 format</h3>


<p>
There are two main differences between the format (wE=8, wF=23) and the IEEE-754 single precision format (the same holds for double).
</p>
<ul> 
  <li><p>Exceptional cases (zeroes, infinities and Not a Number or NaN)
  are encoded as separate bits in FloPoCo, instead of being encoded as
  special exponent values in IEEE-754. This saves quite a lot of decoding/encoding
  logic. The main drawback of
  this format is when results have to be stored in memory, where they
  consume two more bits. However,  FPGA embedded
  memory can accomodate 36-bit data, so adding two bits to a 32-bit IEEE-754 format is harmless as long as data resides within the FPGA.</p><p> As a side effect, the exponent
  can take two more values in FloPoCo than in IEEE-754 (one for very large numbers, one for very small ones).</p>
  </li>
  <li>FloPoCo does not support subnormal numbers. If you think you
	 need subnormal numbers, consider adding one bit to your exponent field
	 instead: you will thus get all the subnormals, and many more. If you
	 are still not convinced, maybe you are right: please get in touch with
	 us.
  </li>  
</ul>

<p>
 Note that anyway, FloPoCo provides conversion operators from and to IEEE-754 formats (simple and double precision).
</p>

<h2>LNS format</h2>

<p>Numbers in the Logarithm Number System used in FloPoCo have an encoding
similar to the floating-point format, which is also the same as the one used in
<a
href="http://www.ens-lyon.fr/LIP/Arenaire/Ware/FPLibrary/">FPLibrary</a>.</p>

<p>Its fields are:
<dl>
  <dt>A 2-bit exception field</dt>
    <dd>Same encoding as floating-point: 00 for zero, 01 for the general case, 10 for infinities, and 11 for NaN</dd>
  <dt>A sign bit</dt>
    <dd>0 for positive, 1 for negative</dd>
  <dt>The integral part of the exponent on wE bits</dt>
  <dt>The fractional part of the exponent on wF bits</dt>
    <dd>The fixed-point exponent is encoded in two's-complement.</dd>
</dl>
</p>


<h2>Pipelining</h2>

<p>An operator may be combinatorial, or pipelined. A combinatorial operator has pipeline depth 0. An operator of pipeline depth 1 is obtained by inserting one and only one register on any path from an input to an output. Hopefully, this divides  the critical path delay by almost 2.  An operator of pipeline depth 2 is obtained by inserting two register levels, etc.</p>

<p>It should be noted that, according to this definition, pipelined
operators usually do not directly buffer neither their inputs nor
their outputs. For instance, connecting the input of a 400MHz operator
to the output of another 400MHz operator may well lead to a circuit
working at 200MHz only. It is the responsibility of the user or
calling program to insert one more level of registers between two
FloPoCo operators. This convention may be felt as a burden to the
user, but it is the most sensible choice. It makes it possible to
assemble sub-component without inserting registers in many situations,
thus reducing the latency of complex components. Besides, different
application contexts may have different policies (registers on output,
or registers on input). <p>

<p>Two command-line options control the pipelining of the FloPoCo
operators that follow them.

<dl>
  <dt><code>-pipeline=[yes|no]</code>  (default yes)</dt>
  <dt><code>-frequency=[frequency in MHz]</code>  (default 300)</dt>
    <dd>Sets the target frequency. If the <code>-pipeline</code>
    option is set, then FloPoCo will try to pipeline the operator to
    the given frequency. It will report a warning if it fails -- or if
    frequency-directed pipelining is not yet implemented for this
    operator.
	 </dd>
    <dd>
		Requires the operators to be pipelined. If <code>no</code>, the operator will be combinatorial. If <code>yes</code>,  registers
		may be inserted if needed to reach the target frequency. 
	 </dd>
</dl>
</p>


<p>The philosophy of FloPoCo's approach to pipelining is the following:
  <ul>
	 <li>FloPoCo's approach is to provide a fair estimate of the pipeline
		depth required to obtain a given frequency, and a sensible placement
		of registers.</li>
	 <li>FloPoCo's pipelining effort is always tentative: You may not
		get the frequency you asked (sometimes you will even get a
		higher one). However, in such cases, increasing or decreasing
		the target frequency should also increase or decrease the
		obtained frequency. Note that you may do so on a per-operator
		basis, as in: <code>flopoco -frequency=200 FPAdder 11 52
		-frequency=300 FPMultiplier 8 23</code></li>

	 <li> If the obtained frequency is higher than needed, reducing
	 the <code>-frequency</code> option may save resources.</li>

	 <li> The pipeline built by FloPoCo may depend on the target. When
	 tuning it, we use the best possible speed grade for a given target
	 family, for insance -12 for Virtex-4. If you want to target a FPGA
	 with a lower speed grade, you may need to
	 update <code>-frequency</code> accordingly.</li>

	 <li> Better results will always be obtained by using retiming
		tools, which can work on a circuit netlist after technology
		mapping. The pipeline built by FloPoCo should help these
		retiming tools converge faster to a global optimal.</li>
  </ul>
</p>
<p>Note that not all operators support pipelining (utimately they all will). They are mentionned in the command-line help.
</p>

<a NAME="AvailableOperators"> </a> 
<h2>Available operators</h2>

<p>Here is the list of operators that can be generated by
FloPoCo. This list may not be fully up-to date... the code is the
reference.</p>

<h3>Useful building blocks for FP operators</h3>

<dl>
  <dt><code>LeftShifter wIn MaxShift</code> </dt>
    <dd>Left barrel shifter. It has two inputs, the data to shift and a shift
      value. The width of the latter is deduced from MaxShift, which is the
      maximum shift distance. This operator will be pipelined to match target
      frequency.</dd>
  <dt><code>RightShifter wIn MaxShift</code> </dt>
    <dd>Same, but to the right.</dd>
  <dt><code>LZOC wIn wOut</code></dt>
    <dd>Leading Zero/One Counter.</dd>
  <dt><code>LZOCShifterSticky wIn wOut computeSticky countType</code></dt>
    <dd>Leading Zero/One Counter merged with a shifter. If
    computeSticky=0 the bits shifted out are discarded, if 1 they are
    ORed into a sticky bit. If countType=0, a leading zero counter is
    built, if 1 a leading one counter is built, if -1 the value to
    count is input from an extra input port.</dd>
</dl>

<h3>Pipelined integer standard operators</h3>
<dl>
  <h4><i> Adders </i></h4>
  <dt><code>IntAdder wIn</code></dt>
    <dd>Integer adder. In modern VHDL, integer addition is expressed by a +
      and one usually needn't define an entity for it. However, this operator
      will be pipelined if the addition is too large to be performed at the
      target frequency. </dd>
  <dt><code>MyIntAdder wIn optimizeType srl implementation bufferedInputs</code></dt>    
      <dd> IntAdder in manual mode. The option <code>optimizeType=<0,1,2,3></code> 
      where <code>0=LUT 1=REG 2=SLICE 3=LATENCY</code> allows selecting the different 
      optimization criteria. <code>srl=<0,1></code> allows generating architectures optimized
      for the use of hardware shift registers. The architecture can also adapt if inputs of the 
      adder are already buffered or not using the option <code>bufferedInputs=<0,1></code>.
      Automatic design space exploration is performed by setting <code>implementation=-1</code>.
      Forcing architecture selection can be done by setting <code>implementation=<0,1,2></code>
      where <code>0=Classical, 1=Alternative, 2=Short-Latency</code>. Please check out this
      <a href="http://prunel.ccsd.cnrs.fr/docs/00/47/57/80/PDF/RR-LIP-2010-16.pdf">article</a>
      for more details.
</dl>
   <h4><i> Multi-operand Adders </i></h4>   
<dl>
   <dt><code>IntNAdder wIn N</code></dt>
    <dd>Multi-operand integer adder using the hardware shift-registers (SRLs for Xilinx)
        available in current FPGAs. 
     </dd>
   <dt><code>IntCompressorTree wIn N</code></dt>
    <dd>Multi-operand integer adder using compressor trees. High quality operator
    at the expense of synthesis time.
     </dd>
</dl>
   <h4><i> Multipliers </i></h4>   
<dl>     
  <dt><code>IntMultiplier wInX wInY</code></dt>
    <dd>Same for multiplication, although the frequency attainable will be
      limited by the DSP blocks available. wInX and wInY are the input widths
      of both operands. This operator fully supports the <code>-DSP_blocks=no</code> option.
      This is an unsigned operation</dd>
    <dd></dd>
  <dt><code>SignedIntMultiplier wInX wInY</code></dt>
     <dd>Same as above but signed and no real support for Altera targets.</dd>
  <dt><code>IntSquarer wInX wInY</code></dt>
    <dd>Same for squaring. For large multiplications on some FPGAs, it
    saves DSP blocks (your mileage may vary).</dd>
    <dd></dd>
  <dt><code>IntKaratsuba wIn</code></dt>
    <dd> Multiplier that saves multiplications by trading them for additions.
    The TwoWaySplitting, ThreeWaySplitting and FourWaySplitting Karatsuba-Ofman algorithms are
    implemented. See this <a href="http://prunel.ccsd.cnrs.fr/docs/00/35/64/21/PDF/RR2009-03.pdf">article</a> for more details.</dd>
    <dd></dd>
  <dt><code>IntTilingMultiplier wInX wInY ratio maxTimeInMinutes</code>
  <dd> Integer multiplier of two integers X and Y of sizes wInX and wInY
      using the tiling technique presented in this <a href="http://prunel.ccsd.cnrs.fr/docs/00/47/57/81/PDF/RR-LIP-2010-15.pdf">article</a>
      The <code>ratio</code> is a number in [0,1] and selects between DSP dominant architectures
      (<code>ratio</code> closer to 1) and logic dominant architectures for <code>ratio</code> closer to 0.  
      The algorithm uses an optimized backtracking approach in exploring the design space and 
      could therefore take a long time to get an optimal solution. The option <code>maxTimeInMinutes</code>
      is used to restrict the maximum amount of time that the algorithm can search for a solution. A value
      of <code>-1</code> for this parameter will find the best solution.</dd>
 	<dd></dd>
  <dt><code>IntTruncMultiplier wInX wInY ratio error useLimits maxTimeInMinutes</code>
  <dd> Truncated integer multiplier of two integers X and Y of sizes wInX and wInY
      using the tiling technique and the specific truncation theory presented in this <a href="http://prunel.ccsd.cnrs.fr/docs/00/47/57/81/PDF/RR-LIP-2010-15.pdf">article</a>
      <code>error</code> gives the maximal allowed error produced by this operator. 
      Two different soft-multiplier expansion techniques can be selected using the
      <code>use limits</code> option but the recommended value is 1.
      </dd>
 	<dd></dd>


</dl>

<h3>Classical floating-point operators</h3> 

These operators are correctly rounded to the nearest, in a way
compatible with IEEE-754, with the exception that subnormal numbers
are flushed to zero.

<dl>
  <dt><code>FPMultiplier wE wF</code></dt>
    <dd>A floating-point multiplier. The actual FloPoCo
      component supports different input and output sizes, but this is
      not available from the command line.</dd>
  <dt><code>FPAdder wE wF</code></dt>
    <dd>A floating-point adder.</dd>
  <dt><code>FPDiv wE wF</code></dt>
    <dd>A floating-point divider.</dd>
  <dt><code>FPSqrt wE wF</code></dt>
    <dd>A floating-point square root using the classical digit-recurrence algorithm. This implementation returns a correctly rounded result, uses no DSP nor RAM blocks and has low LUT usage. However, the latency can be as high as wF for high frequencies, and the frequency is limited for large wF. An alternative is FPSqrtPoly below.</dd>
  <dt><code>FPSqrtPoly wE wF  CorrectlyRounded Degree</code></dt>
    <dd>A floating-point square root using a polynomial approximation. It consumes DSP and RAM blocks, but can reach higher frequencies than FPSqrt, and has lower latency. CorrectlyRounded (0/1) is a boolean selecting the rounding mode. If set to 0, the operator will only be faithful (last-bit accurate, but not necessarily correctly rounded). This saves a lot of resources. Degree is an integer (typically between 2 and 5) that defines the degree of the polynomial approximation, and allows the user to trade-off between DSP usage, latency and memory consumption. Lower degree means lower latency and DSP count, but larger consumption of embedded memory. </dd>
  <dt><code>FPSquarer wE wF</code></dt>
    <dd>A floating-point squarer, using IntSquarer for the mantissa.</dd>
</dl>

<h3>Long fixed-point accumulator, and derivatives</h3>
These operators are described in all the gory details
in <a href="http://prunel.ccsd.cnrs.fr/ensl-00268348/">this
article</a>.
<dl>
  <dt><code>LongAcc wE_in wF_in MaxMSB_in LSB_acc MSB_acc</code></dt>
    <dd>Long fixed-point accumulator. By tuning
    the <code>MaxMSB_in</code>, <code>LSB_acc</code>
    and <code>MSB_acc</code> parameters to a given application, it
    allows one to bring rounding error to a provably arbitrarily small
    level (and in some case to avoid any rounding), for a very small hardware cost compared to using a
    floating-point adder for accumulation.
	 </dd>
  <dt><code>DotProduct wE_in wF_X wF_Y MaxMSB_in LSB_acc MSB_acc</code></dt>
    <dd>Dot product operator. It feeds a long accumulator with the
      unrounded result of a floating-point multiplier, thus removing
      rounding errors from the multiplication as well.
	 </dd>
  <dt><code>LongAcc2FP MaxMSB_in LSB_acc MSB_acc wE_out wF_out</code></dt>
    <dd>  Post-normalisation unit for LongAcc. It converts the output of a
      LongAcc or DotProduct (with the same parameters) into a floating-point
      number.
	 </dd>
</dl>



<h3>Constant multipliers</h3>

<p>This family of operators is described in all the gory details in <a
href="http://prunel.ccsd.cnrs.fr/ensl-00269219/">this article</a>.</p>
<dl>
  <dt><code>IntConstMult w c</code></dt>
    <dd>integer constant multiplier: w is input size, c is the constant.</dd>
  <dt><code>FPConstMult wE_in wF_in wE_out wF_out cst_sgn cst_exp
  cst_int_sig</code></dt>
    <dd>floating-point constant multiplier. The constant is provided as sign,
      integral significand and integral exponent.</dd>
</dl>


<h3>Floating-point elementary functions</h3>

<dl>
	<dt><code>FPExp wE wF</code></dt>
	<dd>An exponential operator, where both inputs and outputs  have <code>wE</code> bits exponent and
	<code>wF</code> bits significand. This operator implements the exponential function as described in
	<a href="http://perso.ens-lyon.fr/florent.de.dinechin/recherche/publis/2007-Arith.pdf">this article</a>.
	</dd>

	<dt><code>FPLog wE wF TableInsize</code></dt>
	<dd>A natural logarithm operator, where both inputs and outputs  have <code>wE</code> bits exponent and
	<code>wF</code> bits significand. The third allows for performance tuning. In doubt, set it to 0, which will default to something sensible. Otherwise, it defines the input size of the tables used by the operator, and should be between 6 and 15. See
<a href="http://perso.ens-lyon.fr/florent.de.dinechin/recherche/publis/2007-Arith.pdf">this article (improved version in preparation)</a>.
	</dd>
</dl>	


<h3>Conversion operators</h3>
<dl>
	<dt><code> Fix2FP LSB MSB wE wF</code></dt>
	<dd>Convert a 2's complement fixed-point number in the bit range MSB...LSB (both
	included) into floating-point. Example: 
	  <code>Fix2FP 0 31 8 23</code> converts an input integer into a single-precision number.
	</dd>
	<dt><code>InputIEEE wEI wFI wEO wFO</code></dt>
	<dd>Conversion from IEEE-754 formats.  Use <code>InputIEEE 8 23 wEO
	wFO</code> to convert from single-precision (or binary32) format,
	or <code>InputIEEE 11 52 wEO wFO</code> to convert from
	double-precision (or binary64) format. You may convert to a larger internal format or to a narrower one. Conversions are always correctly rounded. 
	</dd>
	<dt><code>OurputIEEE wEI wFI wEO wFO</code></dt>
	<dd>Conversion to IEEE-754 formats. Not implemented yet. Do not hesitate to ask for it.
	</dd>
	<dt><code>FP2FP wEI wFI wEO wFO</code></dt>
	<dd>Conversion from a FloPoCo format to another one.  Not implemented yet. Do not hesitate to ask for it.
	</dd>
</dl>	


<h3>Miscelanous floating-point operators</h3>


<dl>
	<dt><code>Collision wE wF</code></dt>
	<dd>A collision operator. This is mostly a case study for a compound operator. It is described in 
	<a href="http://prunel.ccsd.cnrs.fr/ensl-00379154/">this article</a>.
	</dd>
</dl>	



<h3>HOTBM</h3>

<p>This operator implements an arbitrary function using
High-Order Table-Based Method, best described in 
<a href="http://perso.ens-lyon.fr/florent.de.dinechin/recherche/publis/2005-ASAP.pdf">this article</a>.</p>

<dl>
	<dt><code>HOTBM func wI wO degree</code></dt>
	<dt><code>HOTBMFX func wE_in wF_in wE_out wF_out degree</code></dt>
	<dt><code>HOTBMRange func wI wO degree xmin xmax scale</code></dt>
	<dd>HOTBM implementation of a function. <code>func</code> is a
	  sollya-like expression of the function, <code>wI</code> is the
	  input width, <code>wO</code> is the output width and <code>degree</code>
	  is the degree of the Remez polynomial.
	  <code>wE_in</code>, <code>wF_in</code>, <code>wE_out</code>, <code>wF_out</code>
	  are the width of the integral and fractional parts of the input and the output,
	  respectively.
	  [<code>xmin</code>, <code>xmax</code>] is the input domain of the
	  function, and <code>scale</code> is a scaling factor to be applied to
	  the output.
	</dd>
</dl>

<p>For HOTBM the input operand is interpreted as a positive fixed-point number,
with the point before the leftmost bit. The function to be implemented
is assumed to be well defined in [0;1[. The output is a fixed-point
number, where the first bit is the sign and the point is placed right
after it. Note that the output is in fact <code>wO+1</code> bits
wide.</p>

<p>Due to the fact that the expression of the function might contain
characters which are treated specially by the shell, you should
enclose it within quotes.</p>

<p>Example:<br/>
<code>flopoco HOTBM "sin(x*Pi/2)" 16 16 3</code>
</p>

<p>The HOTBMFX version allows to select arbitrary fixed-point representations for the
input and output. Negative values are allowed.</p>

<p>Example:<br/>
<code>flopoco HOTBMFX "log2(1+2^(-x))" 2 8 -1 8 1</code>
</p>

<p>HOTBMRange uses HOTBM after mapping [<code>xmin</code>,<code>xmax</code>[ to [0,1[, then multiplies the output by the scaling factor <code>scale</code>.</p>

<p>Note that this launches an exploration process that typically takes a few minutes for 16 bits, and may take hours for 24 bits.</p>

<p>HOTBM uses a polynomial approximation. It works well for functions
which are regular enough (in mathematical terms, they should be
defined and n-times continuously differentiable on the domain).<p>

<h3>LNS</h3>

<p>These operators compute in the Logarithmic Number System. They are mostly useful
for low-precisions systems performing few additions and many multiplications, divisions
or square roots.</p>

<p>
<dl>
	<dt><code>LNSAddSub wE wF</code></dt>
	<dd>
		LNS addition operator. Both operands and the output have
		<code>wE</code> integral bits and <code>wF</code> fractional
		bits in their exponents.
	</dd>
	<dt><code>LNSMul wE wF</code></dt>
	<dd>
		LNS multiplication operator. Both operands and the output have
		<code>wE</code> integral bits and <code>wF</code> fractional
		bits in their exponents.
	</dd>
	<dt><code>LNSDiv wE wF</code></dt>
	<dd>
		LNS division operator. Both operands and the output have
		<code>wE</code> integral bits and <code>wF</code> fractional
		bits in their exponents.
	</dd>
	<dt><code>LNSSqrt wE wF</code></dt>
	<dd>
		LNS square root operator. Both input and output have
		<code>wE</code> integral bits and <code>wF</code> fractional
		bits in their exponents.
	</dd>
</dl>
</p>

<h3>Test Benches</h3>


<p>The <code>TestBench</code> and <code>TestBenchfile</code> operators generate a test bench for
the operator which precedes it in the command line. The test vectors are generated from the specification of the operator (see the developer documentation of the <code>Operator::emulate()</code> method).</p>

<p>Test cases include both standard tests and random tests. The single parameter <code>n</code> specifies the number of random tests to generate. The pseudo-random number generator is initialised with <code>n</code> as the seed, so that the test bench will be deterministic for a given <code>n</code>. </p>

<p>We strongly advise that you test operators before using them, and we await your bug reports.</p>

<p>
<dl>
	<dt><code>TestBench n</code></dt>
	<dd>
The test vectors are coded in the VHDL of the test bench, and can therefore be easily accessed and modified. In addition, they may include comments. However, this means that the compilation time of the test vectors is large, and this is not convenient beyond a few thousand tests.
<p>Example:<br/>
<code>flopoco HOTBM "sin(x*Pi/2)" 16 16 3 TestBench 1000</code>
</p>
	</dd>
	<dt><code>TestBenchFile n</code></dt>
	<dd>
<code>TestBenchFile</code> is similar to <code>TestBench</code> but moves the test vectors to a separate file called  <code>test.input</code>. Thus the VHDL itself is very short, as is the compilation time. The simulation time is proportional to the number of tests. This scales to millions of test vectors, but is slightly less convenient in the debugging phase.</p>

<p>Example:<br/>
<code>flopoco FPAdder 8 16  TestBenchFile 20000</code>
</p>
	</dd>
</dl>
</p>





<h3>Miscellanous</h3>
<dl>
  <dt><code>Wrapper</code></dt>
    <dd>Produce a wrapper for the preceding operator: this operator simply adds registers before and after the preceding operator.
      It is useful in some cases, e.g. to get critical path information  including the delay of the first and last stages connected to registers, not to I/O.
	 </dd>
</dl>
</body>
</html>
