<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML Basic 1.0//EN"
      "http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd">
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
  <title>FloPoCo user manual</title>
  <meta name="generator" content="Amaya 9.54, see http://www.w3.org/Amaya/" />
</head>

<body>
<h1>FloPoCo user manual</h1>


<h2>Installation</h2>

<p>FloPoCo depends on the MPFR library, available from <a
href="http://www.mpfr.org">http://www.mpfr.org</a> and probably available in
your favourite Linux/Unix distribution. To compile it you need CMake (<a
href="http://www.cmake.org/">http://www.cmake.org/</a>) which also comes
prepackaged for mainstream Linux/Unix distributions.</p>

<p>Optionally, you may want to link FloPoCo
against <a href="http://sollya.gforge.inria.fr/">Sollya</a>. This
enables more operators (HOTBM, CRFPConstMult). For this purpose, you
must download,
compile and install <a href="http://sollya.gforge.inria.fr/">libsollya</a>.
Please note that libsollya is not yet officially supported by the Sollya team, and
interface changes might break FloPoCo compilation. If this is the
case, try to download r588 of libsollya from the SVN repository.</p>

<p>Compilation is a two-step process:</p>

<p><code>cmake .</code></p>

<p><code>make</code></p>

<p>The adventurous may get FloPoCo from its <a
href="https://gforge.inria.fr/scm/?group_id=1030">subversion
repository</a>.</p>


<h2>Command-line interface</h2>

<p>FloPoCo is a command-line tool. The general syntax is</p>

<p><code>flopoco &lt;options&gt; &lt;operator specification
list&gt;</code></p>

<p>FloPoCo will generate a single VHDL file (named by default
<code>flopoco.vhdl</code>) containing synthesisable descriptions of all the
operators listed in <code>&lt;operator specification list&gt;</code>, plus
possibly sub-operators instanciated by them. To use these operators in your
design, just add this generated file to your project.</p>

<p>FloPoCo will also issue a report with useful information about the generated operators, such as the pipeline depth or expected working frequency.</p>

<h3>Examples</h3>

<p><code>./flopoco IntConstMult 16 12345</code></p>

<p>produces a file <code>flopoco.vhdl</code> containing a single operator for
the integer multiplication of an input 16-bit number by the constant 12345.
The VHDL entity is named after the operator specification, here
<code>IntConstMult_16_12345</code>.</p>

<p><code>./flopoco IntConstMult 16 12345 IntConstMult 16 54321</code></p>

<p>produces a file <code>flopoco.vhdl</code> containing two VHDL entities and
their architectures, for the two given constant multipliers. </p>

<p><code>./flopoco FPConstMult 8 23 8 23 0 -50 1768559438007110</code></p>

<p>produces a file flopoco.vhdl containing two VHDL entities, one for the
specified constant floating-point multiplier by 1768559438007110.2-50, and
the other one for a needed sub-component (an integer multiplier for the
significand multiplication).</p>

<h3>Options</h3>

<p>Several options are available and will typically change the operators
occuring after them in the list. For instance <code>-frequency=300</code>
sets the target frequency.</p>

<h3>Built-in help</h3>

<p>To obtain a concise list of the available operators and options, simply
type</p>

<p><code>./flopoco </code></p>

<p>In addition this help may be more in sync with the code than this file,
especially if you are using a svn snpashot.</p>

<h3>Helper programs</h3>

<p>The FloPoCo distributions also includes useful programs for converting the
binary string of a floating-point number to human-readable form
(<code>bin2fp</code>) and back (<code>fp2bin</code>). The
<code>longacc2fp</code> utility converts the fixed-point output of the
LongAcc operator (see below) to human-readable form.</p>

<p></p>

<h2>Floating-point format</h2>

<p>The floating-point format used in FloPoCo is identical to the one used in  <a
href="http://www.ens-lyon.fr/LIP/Arenaire/Ware/FPLibrary/">FPLibrary</a>. It is  inspired from the IEEE-754 standard, from which it differs only for exceptional cases (zeroes, infinities and Not a Number or NaN). </p>

<p>
An FP  number is a bit vector consisting of 4 fields. From left to right: 
<dl>
  <dt>A 2-bit exception field</dt>
    <dd>00 for zero, 01 for normal numbers, 10 for infinities, and 11 for NaN</dd>
  <dt>A sign bit</dt>
    <dd>0 for positive, 1 for negative</dd>
  <dt>An exponent field on wE bits</dt>
    <dd>It is biased as in IEEE-754. The smallest possible FP numbers have exponent field 00...00, the FP  number 1.0 has the exponent field 011...11 and the largest possible FP numbers have exponent 11...11 </dd>
  <dt>A fraction field on wF bits</dt>
    <dd>The actual significand has an implicit leading 1, so the fraction field ff...ff  represents the significand 1.ff...ff</dd>
</dl>
 </p>

<p>The format is therefore parameterized by to positive integers wE
and wF which define the sizes of the exponent and fraction fields
respectively.</p>

<p>The utilities <code>fp2bin</code> and <code>bin2fp</code> will allow
you to get familiar with the format and set up test benches.</p>




<h2>Pipelining</h2>
Two command-line options control the pipelining of the FloPoCo operators that follow them.

<dl>
  <dt><code>-pipeline=[yes|no]</code>  (default yes)</dt>
    <dd>
		Requires the operators to be pipelined. If <code>yes</code>, at least one register
		will be inserted (at the output of the operator), and maybe more
		inside the operator. If <code>no</code>, the operator will be combinatorial.
	 </dd>
  <dt><code>-frequency=[frequency in MHz]</code>  (default 300)</dt>
    <dd>Sets the target frequency. If the <code>-pipeline</code>
    option is set, then FloPoCo will try to pipeline the operator to
    the given frequency. It will report a warning if it fails -- or if
    frequency-directed pipelining is not yet implemented for this
    operator.
	 </dd>
</dl>



<p>Note that pipelined operators (<code>-pipeline=yes</code>) have
		registered outputs, but the inputs to the operator are not
		necessarily registered. </p>


<p>The philosophy of FloPoCo's approach to pipelining is the following:
  <ul>
	 <li>FloPoCo's pipelining effort is always tentative: You may not get
		the frequency you asked (sometimes you will even get a higher one). However, in such
		cases, increasing or decreasing the target frequency should also
		increase or decrease the obtained frequency.</li>
	 <li> Better results will always be obtained by using retiming tools, which
		can work on a circuit netlist after technology mapping.</li>
	 <li>FloPoCo's approach is to provide a fair estimate of the pipeline
		depth required to obtain a given frequency, and a sensible placement
		of registers.</li>
  </ul>
</p>


<h2>Available operators</h2>

<p>Here is the list of operators that can be generated by
FloPoCo. This list may not be fully up-to date... the code is the
reference.</p>

<h3>Useful building blocks for FP operators</h3>

<dl>
  <dt><code>LeftShifter wIn MaxShift</code> </dt>
    <dd>Left barrel shifter. It has two inputs, the data to shift and a shift
      value. The width of the latter is deduced from MaxShift, which is the
      maximum shift distance. This operator will be pipelined to match target
      frequency.</dd>
  <dt><code>RightShifter wIn MaxShift</code> </dt>
    <dd>Same, but to the right.</dd>
  <dt><code>LZOC wIn wOut</code></dt>
    <dd>Leading Zero/One Counter (mostly untested).</dd>
</dl>

<h3>Pipelined integer standard operators</h3>
<dl>
  <dt><code>IntAdder wIn</code></dt>
    <dd>Integer adder. In modern VHDL, integer addition is expressed by a +
      and one usually needn't define an entity for it. However, this operator
      will be pipelined if the addition is too large to be performed at the
      target frequency. </dd>
  <dt><code>IntMultiplier wInX wInY</code></dt>
    <dd>Same for multiplication, although the frequency attainable will be
      limited by the DSP blocks available. wInX and wInY are the input widths
      of both operands. This is an unsigned operation.</dd>
    <dd></dd>
</dl>

<h3>Classical floating-point operators</h3>
<dl>
  <dt><code>FPMultiplier wEX wFX wEY wFY wER wFR</code></dt>
    <dd>A floating-point multiplier, with pepper: it may multiply number of
      different precisions, and provide you with the correct rounding to
      arbitrary precision -- including an exact result if wFR is larger than
      wFX+wFY+1.</dd>
  <dt><code>FPAdder wEX wFX wEY wFY wER wFR</code></dt>
    <dd>A floating-point adder, with pepper: it may multiply number of
      different precisions, and provide you with the correct rounding to
      arbitrary precision -- including an exact result if wFR is larger than
      wFX+wFY+1.</dd>
</dl>

<h3>Long fixed-point accumulator</h3>
<dl>
  <dt><code>LongAcc wE_in wF_in MaxMSB_in LSB_acc MSB_acc</code></dt>
    <dd>This operator is described in all the gory details in <a
      href="http://prunel.ccsd.cnrs.fr/ensl-00268348/">this article</a>.
	 </dd>
  <dt><code>LongAcc2FP MaxMSB_in LSB_acc MSB_acc wE_out wF_out</code></dt>
    <dd>  Post-normalisation unit for LongAcc. It converts the output of a
      LongAcc (with the same parameters) into a floating-point
      number. See <a href="http://prunel.ccsd.cnrs.fr/ensl-00268348/">this
      article</a> for details.
	 </dd>
</dl>



<h3>Constant multipliers</h3>

<p>This family of operators is described in all the gory details in <a
href="http://prunel.ccsd.cnrs.fr/ensl-00269219/">this article</a>.</p>
<dl>
  <dt><code>IntConstMult w c</code></dt>
    <dd>integer constant multiplier: w is input size, c is the constant.</dd>
  <dt><code>FPConstMult wE_in wF_in wE_out wF_out cst_sgn cst_exp
  cst_int_sig</code></dt>
    <dd>floating-point constant multiplier. The constant is provided as sign,
      integral significand and integral exponent.</dd>
</dl>


<h3>Floating-point elementary functions</h3>

<dl>
	<dt><code>FPExp wE wF</code></dt>
	<dd>An exponential operator, where both inputs and outputs  have <code>wE</code> bits exponent and
	<code>wF</code> bits significand. This operator implements the exponential function as described in
	<a href="http://jeremie.detrey.free.fr/publications/DetDinPuj_arith_2007.pdf">this article</a>.
	</dd>

	<dt><code>FPLog wE wF</code></dt>
	<dd>A natural logarithm operator, where both inputs and outputs  have <code>wE</code> bits exponent and
	<code>wF</code> bits significand. This operator implements the natural logarithm function as described in
<a href="http://jeremie.detrey.free.fr/publications/DetDinPuj_arith_2007.pdf">this article</a>.
	</dd>
</dl>	

<h3>HOTBM</h3>

<p>This operator implements an arbitrary function using
High-Order Table-Based Method, best described in 
<a href="http://perso.ens-lyon.fr/florent.de.dinechin/recherche/publis/2005-ASAP.pdf">this article</a>.</p>

<dl>
	<dt><code>HOTBM func wI wO degree</code></dt>
	<dd>HOTBM implementation of a function. <code>func</code> is a
	  sollya-like expression of the function, <code>wI</code> is the
	  input width, <code>wO</code> is the output width and <code>degree</code>
	  is the degree of the Remez polynomial.
	</dd>
</dl>

<p>The input of the HOTBM operand is interpreted as a fixed-point number,
with the point before the leftmost bit. The function to be implemented
is assumed to be well defined in [0;1[. The output is a fixed-point
number, where the first bit is the sign and the point is placed right
after it. Note that the output is in fact <code>wO+1</code> bits
wide.</p>

<p>Due to the fact that the expression of the function might contain
characters which are treated specially by the shell, you should
enclose it within quotes.</p>

<p>Example:<br/>
<code>flopoco HOTBM "sin(x*Pi/2)" 16 16 3</code>
</p>

<p>Note that this launches an exploration process that typically takes a few minutes for 16 bits, and may take hours for 24 bits.</p>

<p>HOTBM uses a polynomial approximation. It works well for functions
which are regular enough (in mathematical terms, they should be
defined and n-times continuously differentiable on the domain).<p>



<h3>Test Benches</h3>

The <code>TestBench</code> operator will generate a test bench for
the operator which precedes it in the command line (also called
unit under test, UUT).

Test cases are highly UUT specific. They include both standard tests
and random tests. The single parameter of the <code>TestBench</code>
specifies the number of random tests to generate. Random tests
are generating using a pseudo-random number generator, being
initialised with the same seed, so that the test bench will be
deterministic.

Currently, only the following operators are able to generate test cases
required for test bench generation: <code>HOTBM</code>,
 <code>IntMultiplier</code>, <code>FPAdder</code>, <code>FPMultipier</code>, <code>IntConstMult</code>,
<code>FPConstMult</code>, <code>FPExp</code>, <code>FPLog</code>.

<p>Example:<br/>
<code>flopoco HOTBM "sin(x*Pi/2)" 16 16 3 TestBench 1000</code>
</p>

<code>BigTestBench</code> is similar to <code>TestBench</code> but is
optimized for large tests (up to 1 million). It generates a very short VHDL code, which
reads test vectors from a predetermined file (the filename is
<code>operator_unique_name.test</code>). However, <code>BigTestBench</code> has the
disadvantage that the test file looks like a big blob and it is very hard to debug
problems, especially for pipelined designs. Therefore, it is recommended to use this
operator only when <code>TestBench</code> is successful, and one wants to be really
sure that the UUT is working perfectly.

<p>Example:<br/>
<code>flopoco FPExp 8 16 BigTestBench 200000</code>
</p>

<h3>Miscellanous</h3>
<dl>
  <dt><code>Wrapper entity_name</code></dt>
    <dd>Produce a wrapper named entity_name for the preceding operator
      (useful to get synthesis results without having the operator optimised
      out)</dd>
</dl>
</body>
</html>
